{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-30T00:01:18.661860+00:00",
  "repo": "marten-seemann/draft-seemann-quic-address-discovery",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOKhxVW850URwl",
      "title": "mention NAT rebindings",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/1",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "It might make sense to re-probe a path every once in a while to detect NAT rebindings.",
      "createdAt": "2023-10-19T07:21:25Z",
      "updatedAt": "2023-10-19T07:31:45Z",
      "closedAt": "2023-10-19T07:31:45Z",
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOKhxVW850a3dg",
      "title": "0-RTT",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/3",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am fairly confident that these frames are safe to send in 0-RTT.",
      "createdAt": "2023-10-19T23:21:48Z",
      "updatedAt": "2024-08-20T06:56:45Z",
      "closedAt": "2024-08-20T06:56:45Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "The draft states that the frames allowed in the application-data packet number space (which includes both 0-RTT and 1-RTT), and it also requires endpoints to remember the value of the transport parameter for 0-RTT.\r\n\r\nDo you have an editorial suggestion to make it clearer that these frames are allowed in 0-RTT?",
          "createdAt": "2023-10-20T02:01:17Z",
          "updatedAt": "2023-10-20T02:01:17Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "We do have text in Section 3:\r\n\r\n_When using 0-RTT, both endpoints MUST remember the value of this transport parameter. This allows sending the frame defined by this extension in 0-RTT packets. If 0-RTT data is accepted by the server, the server MUST NOT disable this extension or change the value on the resumed connection_\r\n\r\nI think that does address the issue. @martinthomson, do you agree?",
          "createdAt": "2024-08-20T06:32:07Z",
          "updatedAt": "2024-08-20T06:32:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That would do it, yes.",
          "createdAt": "2024-08-20T06:49:04Z",
          "updatedAt": "2024-08-20T06:49:04Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOKhxVW850a3sd",
      "title": "Repeated requests",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/4",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "What if an endpoint receives two requests from different source addresses?",
      "createdAt": "2023-10-19T23:23:04Z",
      "updatedAt": "2024-02-27T01:48:11Z",
      "closedAt": "2024-02-27T01:48:11Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "That\u2019s ok, and in fact, that\u2019s expected when the connection is probing different paths. The sequence number allows the requests and responses to be distinguished from each other.",
          "createdAt": "2023-10-20T02:03:21Z",
          "updatedAt": "2023-10-20T02:03:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I was specifically talking about the case where the same sequence number appears.\r\n\r\nI think that you want to say that the sequence number (really, a request ID) is just there to help the requester distinguish answers.  The responder just echoes the value back (and responds to every request it receives, even apparent duplicates).",
          "createdAt": "2023-10-20T05:04:57Z",
          "updatedAt": "2023-10-20T05:04:57Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I agree. This makes a lot of sense, and will become a lot more apparent once we rename the field to request ID.",
          "createdAt": "2023-10-20T05:18:44Z",
          "updatedAt": "2023-10-20T05:18:44Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOKhxVW850a4HW",
      "title": "Sequence number or just unique?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Because the sequence number is simply echoed, it might not need to be monotonic.  It should be enough to just have it be unique.  Obviously, a counter is the easiest method to use, but given typical usage, it might be OK to send the same value always.  If the endpoint that responds does so unconditionally (without collapsing duplicates, see #4), then this will probably be enough for most endpoints to get what they need (that is, the set of reflexive addresses they have).",
      "createdAt": "2023-10-19T23:25:30Z",
      "updatedAt": "2024-02-11T01:53:51Z",
      "closedAt": "2024-02-11T01:53:51Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "It\u2019s correct that we only need a unique value, but using a sequence number makes it easier to detect the error condition (when your peer sends you a response for a request you didn\u2019t send).\r\n\r\nMaybe we should just point that out, and rename it to \u201cRequest ID\u201d or something like that?",
          "createdAt": "2023-10-20T01:59:16Z",
          "updatedAt": "2023-10-20T01:59:16Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOKhxVW850cTOP",
      "title": "Document multipath operation?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/6",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In a multipath environment, the client is likely to use different addresses on different paths, either because the paths are bound to different addresses or network interfaces at the client, or because different paths are mapped differently by various NAT. It is interesting to discover on which path an address was observed.\r\n\r\nI think this is possible with the current description:\r\n~~~\r\nOBSERVED_ADDRESS Frame {\r\n       Type (i) = 0x9f81a2..0x9f81a3,\r\n       Sequence Number (i),\r\n       [ IPv4 (32) ],\r\n       [ IPv6 (128) ],\r\n       Port (16),\r\n   }\r\n~~~\r\nThe client has to remember on which path a particular `REQUEST_ADDRESS` was sent, and can then match that to the sending path.\r\n\r\nSo, not really an issue, except maybe it could be discussed in an \"operation consideration\" or \"multipath consideration\" section.\r\n",
      "createdAt": "2023-10-20T05:46:03Z",
      "updatedAt": "2024-08-20T06:25:37Z",
      "closedAt": "2024-08-20T06:25:37Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "It's not only needed in QUIC Multipath, vanilla QUIC also requires the requester to remember the path. The frames are intentionally defined as probing frames, so you can send them in probing packets during the path validation phase, and you might be probing multiple paths in parallel.",
          "createdAt": "2023-10-20T07:46:01Z",
          "updatedAt": "2023-10-20T07:46:01Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that we need a bit of editing there. The current text says (section 4.1 Observed Address frame):\r\n~~~\r\nRequest ID:\r\n    The request identifier of the request for which this response is intended.\r\n~~~\r\n.. but there is no request defined, thus no ID to copy.\r\n\r\nIf the multipath extension is negotiated, it might be nice to stick there a path-id that identifies the path using the observed address, and maybe stipulate to set the path-id to 0 if the multipath extension is not negotiated.\r\n\r\nIt might also be nice to have some kind of counter, separate from the path ID, to distinguish new values from old packets repeated because of loss recovery.",
          "createdAt": "2024-08-19T22:47:27Z",
          "updatedAt": "2024-08-19T22:47:27Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the issue is addressed by PR #14 (Remove request ID) and PR  #15 (Clarify that retransmissions happen on same path).",
          "createdAt": "2024-08-20T06:25:37Z",
          "updatedAt": "2024-08-20T06:25:37Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOKhxVW850c24K",
      "title": "consider moving away from request-response",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/7",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "On the mailing list, Igor proposed to move away from a request-response scheme, and have nodes report the observed address without being requested to do so.\r\n\r\nWe could change the logic such that negotiating this extension means that:\r\n1. Endpoints are expected to inform their peer of the observed address after completion of the handshake (or maybe even in Handshake packets during the handshake?).\r\n2. Include\u00a0a NEW_OBSERVED_ADDRESS frame in probing packets on a new path.\r\n3. Send a NEW_OBSERVED_ADDRESS whenever the remote address changes on a path (e.g. due to a NAT rebinding).\r\n \r\nWe might use the value of the transport parameter to distinguish between \"I'm willing to report your address\" and \"I'm requesting that you send me NEW_OBSERVED_ADDRESS frames\".",
      "createdAt": "2023-10-20T07:40:51Z",
      "updatedAt": "2024-02-27T01:48:10Z",
      "closedAt": "2024-02-27T01:48:10Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "That's cool, but then the NEW OBSERVED ADDRESS needs to be tied to a path number. Otherwise, the client will not be able to tell. \r\nMaybe just copy the CID of the packet for which the new address was observed?",
          "createdAt": "2023-10-21T00:48:58Z",
          "updatedAt": "2023-10-21T00:48:58Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "@huitema I don\u2019t think that\u2019s necessary. Your QUIC stack will know the path it received the from on, won\u2019t it?",
          "createdAt": "2023-10-21T01:45:26Z",
          "updatedAt": "2023-10-21T01:45:26Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "No, because you do not want to constraint the address observed frames to be on the \"same path\". Especially when doing discovery/ice, because there id no guarantee that the \"same path\" is working in both directions.",
          "createdAt": "2023-10-21T03:55:29Z",
          "updatedAt": "2023-10-21T03:55:29Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "You're right. I hadn't considered unidirectional paths. Adding the CID would indeed be a solution, but there are downsides to coupling ourselves to the CID state machine: the CID might have been retired in the mean time. Not saying that this isn't possible, but we need to think about corner cases very carefully.",
          "createdAt": "2023-10-21T03:59:44Z",
          "updatedAt": "2023-10-21T03:59:44Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "The CID is only retired if the client who sent the traffic decides to retire it. In that case, the client won't be able to match the IP address with a path, which is not good but also not the end of the world.",
          "createdAt": "2023-10-21T06:12:28Z",
          "updatedAt": "2023-10-21T06:12:28Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOKhxVW86Tfdq1",
      "title": "Handling of repeated observed address frames",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/12",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec says that \"OBSERVED_ADDRESS frames are ack-eliciting, and SHOULD be retransmitted if lost.\" In a multipath environment, this is a bit problematic, because there is generally no guarantee that the frame will be resent on the same path as the first transmission. Indeed, it often makes a lost of sense to resend the content of lost packets on a different path, in particular when the original path is broken.\r\n\r\nThere are two potential fixes: \r\n\r\n1. encode a path ID in the frame, as in \"I have observed this address and port on path number 42\". This would be in line with multipath management frames like PATH_ABANDON or MP_ACK.\r\n2. add a recommendation that \"OBSERVED_ADDRESS frames MUST be sent on the same path over which the address was received.\"\r\n\r\nThe first option is the natural solution when the multipath extension is negotiated.\r\n\r\nThe second option can be implemented, but is a bit painful. If I had to do that, I would just tie the OBSERVED_ADDRESS frames to PATH_CHALLENGE frames, and repeat them when the PATH_CHALLENGE needs to be repeated.",
      "createdAt": "2024-08-20T00:37:01Z",
      "updatedAt": "2024-08-20T04:33:45Z",
      "closedAt": "2024-08-20T04:22:04Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I'd prefer to not have a dependency on QUIC multipath. Sure, you could set this field to 0 when using pure RFC 9000 QUIC, but it would be nice if we didn't have to do that.\r\n\r\nWhen we a request-response protocol, we had the concept of a Request ID (remnants of which you can still see in the OBSERVED_ADDR frame, see #13), which tied a response to a request. This meant that it didn't matter which path the response was sent on.\r\n\r\n\r\n\r\n> 2\\. add a recommendation that \"OBSERVED_ADDRESS frames MUST be sent on the same path over which the address was received.\"\r\n\r\nI think this is what we should do. I'm not sure how painful it is to implement, but I imagine that any multipath implementation will need some logic to tie certain frames to a specific path anyway.",
          "createdAt": "2024-08-20T02:56:30Z",
          "updatedAt": "2024-08-20T02:56:30Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Having the server (or the responder) send an observed frame each time it observes a new address is nice -- address changes due to NAT or whatever and poof, you get a frame. But there are potential issues, and a request response may be preferable after all.\r\n\r\nFirst, the address \"changes\" may be trigger by third parties: capture a packet, make sure it does not reach its destination, then send it from an arbitrary address. The reaction to NAT traversal is a little slower, but could be triggered by the CID rotation done by the peer. The request mode seems a bit less prone to outside interference.",
          "createdAt": "2024-08-20T04:18:43Z",
          "updatedAt": "2024-08-20T04:18:43Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "> First, the address \"changes\" may be trigger by third parties: capture a packet, make sure it does not reach its destination, then send it from an arbitrary address.\r\n\r\nI'm wondering if this could be used by an on-path attacker to trigger a Honeybadger-style DoS attack: Capture all packets, and send them from 2 different interfaces in an alternating way, thereby triggering the sending of lots of OBSERVED_ADDRESS frames.\r\n\r\nOn the other hand, this attack is already possible, as any change in path requires the peer to go through path validation.",
          "createdAt": "2024-08-20T04:25:03Z",
          "updatedAt": "2024-08-20T04:25:03Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually simulate an attack like that in the picoquic test suite, for testing the robustness of NAT traversal. There are no good defense, but the code should at a minimum dampen the attack. Maybe document that in security considerations?",
          "createdAt": "2024-08-20T04:33:44Z",
          "updatedAt": "2024-08-20T04:33:44Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOKhxVW86Tf5Fk",
      "title": "remove REQUEST_ID from OBSERVED_ADDR frame",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/13",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This is not needed anymore, since we moved away from request - response.",
      "createdAt": "2024-08-20T02:54:50Z",
      "updatedAt": "2024-08-20T04:25:23Z",
      "closedAt": "2024-08-20T04:25:23Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOKhxVW86TgOxy",
      "title": "Differentiate old and new values of observed address",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/17",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Assume the following scenario:\r\n\r\n* Server observes an NAT rebinding, sends \"observed address\" frame number 1,\r\n* Packet carrying the observed address frame is lost\r\n* Server observes an NAT rebinding, sends \"observed address\" frame number 2,\r\n* Client receives \"observed address\" frame number 2,\r\n* Server notices the loss and repeats \"observed address\" frame number 1,\r\n* Client receives \"observed address\" frame number 1.\r\n\r\nThus, client is confused...\r\n\r\nWe have generally treated such issues by adding a monotonically increasing sequence number to the frame, so we can retain only the last one, or the last one for a given path. See for example the PATH_STANDBY and PATH_AVAILABLE multipath frames.",
      "createdAt": "2024-08-20T04:37:14Z",
      "updatedAt": "2024-08-21T05:19:42Z",
      "closedAt": "2024-08-21T05:19:42Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "The server should probably not retransmit stale values, but the problem still exists since two packets contain two OBSERVED_ADDRESS frames could be reordered in the network. This is especially relevant in this case, as the different paths could exhibit different RTTs.\r\n\r\nAdding a sequence number sounds like a reasonable solution.",
          "createdAt": "2024-08-20T04:46:42Z",
          "updatedAt": "2024-08-20T04:46:42Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOKhxVW86TgO8i",
      "title": "add packet rerouting attack defense to security considerations",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/18",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "              I actually simulate an attack like that in the picoquic test suite, for testing the robustness of NAT traversal. There are no good defense, but the code should at a minimum dampen the attack. Maybe document that in security considerations?\r\n\r\n_Originally posted by @huitema in https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/12#issuecomment-2297946124_\r\n            ",
      "createdAt": "2024-08-20T04:38:01Z",
      "updatedAt": "2024-08-24T02:46:03Z",
      "closedAt": "2024-08-24T02:46:03Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOKhxVW86TgVtb",
      "title": "request shorter frame code points before RFC publication",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/20",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A 2-byte code point would be nice.",
      "createdAt": "2024-08-20T05:07:50Z",
      "updatedAt": "2024-11-08T08:24:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not really understand the process either. I was expecting some kind of form, but apparently we just need to send an email to the IANA, explaining that we need a code for a transport type and also two consecutive codes for the frame types. If we have to propose values, I would go with 0xAD1 for the \"Address Discovery\" TP, and 0x0B5A and 0x0B5B for the observed addresses V4 and V6 (OBServed A and OBServed B), but that's just because I like mnemonics.\r\n\r\nBut I wonder whether we should wait for WG adoption... which my take a bit more time.",
          "createdAt": "2024-08-24T04:51:21Z",
          "updatedAt": "2024-08-24T04:51:21Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I agree. We can always change code points and bump the draft version.",
          "createdAt": "2024-08-24T05:20:37Z",
          "updatedAt": "2024-08-24T05:20:37Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "@nibanks had a suggestion for a particular 2-byte code points. Would you mind posting them here?",
          "createdAt": "2024-11-07T11:03:45Z",
          "updatedAt": "2024-11-07T11:03:45Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "NONE",
          "body": "I started implementing this in msquic and I just shortened what you had to:\r\n```c\r\n    QUIC_FRAME_OBSERVED_ADDRESS_V4  = 0x9f81ULL,\r\n    QUIC_FRAME_OBSERVED_ADDRESS_V6  = 0x9f82ULL,\r\n```",
          "createdAt": "2024-11-07T11:14:29Z",
          "updatedAt": "2024-11-07T11:14:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "@nibanks these numbers are larger than 2^14, and will be encoded on 4 bytes. If we want two bytes, we should use something like:\r\n```c\r\n    QUIC_FRAME_OBSERVED_ADDRESS_V4  = 0x1f81ULL,\r\n    QUIC_FRAME_OBSERVED_ADDRESS_V6  = 0x1f82ULL,\r\n```",
          "createdAt": "2024-11-07T23:01:15Z",
          "updatedAt": "2024-11-07T23:01:15Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "NONE",
          "body": "Ah, you're right. I'm fine with those values you suggest.",
          "createdAt": "2024-11-08T08:24:43Z",
          "updatedAt": "2024-11-08T08:24:43Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOKhxVW86TgvC1",
      "title": "Do we really need to allow this frame in handshake packets?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/21",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Handshake packets are received by the client *before* the negotiation of transport parameters completes, thus the client does not know whether the frames are authorized or not. Disallowing these frames in handshake packets would simplify the implementation, with very little impact on performance.",
      "createdAt": "2024-08-20T06:35:46Z",
      "updatedAt": "2024-08-22T06:32:51Z",
      "closedAt": "2024-08-22T06:32:51Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "Makes sense. You can just send them in 0.5-RTT data instead, potentially in the same (coalesced) packet.",
          "createdAt": "2024-08-20T09:29:31Z",
          "updatedAt": "2024-08-20T09:29:31Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOKhxVW86To9j5",
      "title": "Transport Parameter should reserve value 0 for Unsupported",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/24",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "The current definition of the `address_discovery` parameter specifies 3 possible values:\r\n\r\n0. The node is willing to provide address observations to its peer, but is not interested in receiving address observations itself.\r\n1. The node is interested in receiving address observations, but it is not willing to provide address observations.\r\n2. The node is interested in receiving address observations, and it is willing to provide address observations.\r\n\r\nThere is a hidden value, \"parameter absent\", that means \"address discovery is not supported.\" That requires managing an additional boolean in the implementation, to specify to not send this parameter.\r\n\r\nI think that it would be simpler to explicitly have 4 values:\r\n\r\n0. Address discovery is not supported. This is the default value if the parameter is absent.\r\n1. The node is willing to provide address observations to its peer, but is not interested in receiving address observations itself.\r\n2. The node is interested in receiving address observations, but it is not willing to provide address observations.\r\n3. The node is interested in receiving address observations, and it is willing to provide address observations.\r\n\r\n If the value is 0, the implementation should not send the parameter.\r\n\r\nThis does not create any additional overhead, since we always need one byte to encode the value.",
      "createdAt": "2024-08-21T03:53:57Z",
      "updatedAt": "2024-08-22T06:54:53Z",
      "closedAt": "2024-08-22T06:54:53Z",
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "I'm not sure I understand the problem. How you store this in your implementation is independent from how we encode things on the wire. It's totally reasonable to have an enum with the 4 states you describe to represent the state of this extension.",
          "createdAt": "2024-08-21T03:59:11Z",
          "updatedAt": "2024-08-21T03:59:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "That's indeed what I do, 4 values internally, 3 values on the wire. But it is a bit of gratuitous complexity. 4 values on the wire would be just as easy to process as 3 values, and would simplify the code. Not a huge deal, of course, but I did get confused when writing my unit test, and other developers could be.",
          "createdAt": "2024-08-21T04:13:47Z",
          "updatedAt": "2024-08-21T04:13:47Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "Do we have any precedent for explicitly encoding \"I don't support this extension\" in other QUIC extensions? I see little value in explicitly encoding this on the wire.",
          "createdAt": "2024-08-22T03:31:09Z",
          "updatedAt": "2024-08-22T03:31:09Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 9218, QUIC Datagrams, advertises the maximum length of a datagram frame. Value 0 means \"not supported.\"",
          "createdAt": "2024-08-22T06:07:44Z",
          "updatedAt": "2024-08-22T06:07:44Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "That's 9221, and I interpret the RFC differently. It just means that you don't support _receiving_ DATAGRAM frames.",
          "createdAt": "2024-08-22T06:32:33Z",
          "updatedAt": "2024-08-22T06:32:33Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the wrong number. But, fine, let's keep the text as is.",
          "createdAt": "2024-08-22T06:52:30Z",
          "updatedAt": "2024-08-22T06:52:30Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOKhxVW86WL6_-",
      "title": "What happens when the OBSERVED_ADDRESS frame's Sequence Number overflows?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/27",
      "state": "CLOSED",
      "author": "flub",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It is theoretically possible that the Sequence Number of an OBSERVED_ADDRESS frame overflows for a connection.  What the implementation should do is left undefined currently as far as I understand.\r\n\r\nGenerally I think QUIC tends to immediately close a connection with an error if a counter overflows.  Is this the right behaviour here as well?  Should it be specified?",
      "createdAt": "2024-09-11T13:08:15Z",
      "updatedAt": "2024-09-17T13:20:14Z",
      "closedAt": "2024-09-17T08:28:14Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "In theory it could happen, but 2^62 is a really big number -- 18 billions of billions. The event that you describe will not happen before the end of the universe if the server merely increases the counter by 1 for each new address, supposing of course that the connection stays up that long.\r\n\r\nOf course, the roll over could happen if the server deliberately makes it happen, for example by incrementing the counter by 2^60 for each new address. Don't do that.",
          "createdAt": "2024-09-12T19:22:06Z",
          "updatedAt": "2024-09-12T19:22:06Z"
        },
        {
          "author": "flub",
          "authorAssociation": "NONE",
          "body": "The spec says it MUST be monotonically increased so you're not allowed to jump as I read it.  So yeah, don't do that :)\r\n\r\nThough don't we have to know how we should react if some peer is maliciously increasing this number?",
          "createdAt": "2024-09-17T07:55:16Z",
          "updatedAt": "2024-09-17T07:57:37Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "The receiver doesn't care about the absolute value of the sequence number, all it cares about is that it can ignore any frames with a smaller sequence number than the highest received.\r\n\r\nReally, we've discussed this time and time again during the QUIC specification process. As Christian says, 2^62 is a really big number.",
          "createdAt": "2024-09-17T08:28:15Z",
          "updatedAt": "2024-09-17T08:28:15Z"
        },
        {
          "author": "flub",
          "authorAssociation": "NONE",
          "body": "> Really, we've discussed this time and time again during the QUIC specification process. As Christian says, 2^62 is a really big number.\r\n\r\nIs the rationale for this written down anywhere, maybe in RFC9000 or any related documents?  That could help with understanding the nuances.  This is still something that the type system forces us to make *some* decision on.",
          "createdAt": "2024-09-17T13:20:12Z",
          "updatedAt": "2024-09-17T13:20:12Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOKhxVW86dOhul",
      "title": "acknowledge draft-pauly-quic-address-extension",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/30",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "David Schinazi suggested acknowledging https://datatracker.ietf.org/doc/draft-pauly-quic-address-extension/. I was not aware of this draft when I wrote up the first version of my draft (as far as I can tell, it was never discussed on the QUIC mailing list), but the idea is quite similar.",
      "createdAt": "2024-11-06T11:30:51Z",
      "updatedAt": "2024-11-08T08:31:37Z",
      "closedAt": "2024-11-08T08:31:36Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. It is indeed similar, and deserves to be acknowledged.",
          "createdAt": "2024-11-07T05:38:50Z",
          "updatedAt": "2024-11-07T05:38:50Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOKhxVW86dQngO",
      "title": "Really Need Configurable Behavior?",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/31",
      "state": "OPEN",
      "author": "nibanks",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Right now the transport parameter allows for configurable behavior as such:\r\n\r\n```\r\n* 0: The node is willing to provide address observations to its peer, but is not\r\n  interested in receiving address observations itself.\r\n* 1: The node is interested in receiving address observations, but it is not\r\n  willing to provide address observations.\r\n* 2: The node is interested in receiving address observations, and it is willing\r\n  to provide address observations.\r\n```\r\n\r\nIt's obviously simpler to implement if it's just always on (if supported). What is the desire behind supporting a configurable behavior like this, considering these frames will be exchanged so infrequently? I understand servers might not need addresses from the client, but it would want to support sending them. But the implementation cost (IMO) isn't worth saving a few bytes from the client.\r\n\r\nMy preference would be a zero payload TP that indicates I support sending and receiving the addresses.",
      "createdAt": "2024-11-06T15:11:08Z",
      "updatedAt": "2024-11-07T11:18:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "In addition to public servers not being interested in receiving address observations, you might not be able to do so either, for example if you're the endpoint of a CONNECT-UDP connection.\r\n\r\nYou will know that this is the case, since you're the client who established the CONNECT-UDP connection, and you'd set the corresponding mode for the address discovery extension.",
          "createdAt": "2024-11-07T11:06:12Z",
          "updatedAt": "2024-11-07T11:06:12Z"
        },
        {
          "author": "nibanks",
          "authorAssociation": "NONE",
          "body": "That makes sense. I think we'll ultimately not be able to simplify this further. Though, I did have one thought: What if it was simplified and you only _actually_ sent something if you could? What is the impact of not sending an observed address, even if the peer wants you to (and thinks you should) send it? ",
          "createdAt": "2024-11-07T11:18:05Z",
          "updatedAt": "2024-11-07T11:18:05Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOKhxVW86dWtEx",
      "title": "Add motivation paragraph in introduction",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/32",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "huitema"
      ],
      "labels": [],
      "body": "\r\nFrom the logs of the Zulip chatroom:\r\n\r\nFrom | Text\r\n-----|-----\r\nMartin Thomson | That STUN argument is not a good one.  Is there a better argument for using QUIC?  It seems like there might be.\r\nMartin Thomson | _That STUN argument_ refers to the argument that Marten used to argue against using STUN.\r\nChristian Huitema | Martin: I like that we can have address discovery potentially with ANY server. It is good for P2P, because of \"don't stick out\". But it can also be used for debug, etc.\r\nMartin Thomson | Christian: that's a good one.\r\nMartin Thomson | I think that the authentication in STUN is also particularly complex for this purpose.\r\nMartin Thomson | STUN relies on shared keys, which would mean the use of exporters or something like that.\r\nChristian Huitema | Yes, having everything encrypted is a also a huge plus.",
      "createdAt": "2024-11-07T05:59:23Z",
      "updatedAt": "2024-11-07T22:57:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "@huitema Can you propose some text?",
          "createdAt": "2024-11-07T11:10:14Z",
          "updatedAt": "2024-11-07T11:10:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "body": "Will do.",
          "createdAt": "2024-11-07T22:57:25Z",
          "updatedAt": "2024-11-07T22:57:25Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOKhxVW86dWunr",
      "title": "Load balancing gateway",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/33",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From the minutes of the QUIc WG session at IETF 121:\r\n\r\nJaroslav??: If you have a client is on path that uses per packet load-balancing. Here you would receive this frame per packet. Rate limiting?\r\n\r\nMarten: You describe a NAT rebinding that happens very often (looks like that to the server). RFC 9000 sees this as an attack. Do the same thing as for path validation.\r\n\r\n",
      "createdAt": "2024-11-07T06:04:04Z",
      "updatedAt": "2024-11-07T11:02:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "Was this resolved by #23?",
          "createdAt": "2024-11-07T11:02:57Z",
          "updatedAt": "2024-11-07T11:02:57Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOKhxVW86dWu3Q",
      "title": "Layers of NATs and proxies",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/issues/34",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From the minutes of QUIc at IETF 121\r\n\r\nLorenzo C: What if the Masque server does not have a public IP. Would you use STUN with this?\r\n\r\nMarten: You could chain proxies\u2026 you would need to deal with this. Use of multiple nodes\u2026",
      "createdAt": "2024-11-07T06:04:52Z",
      "updatedAt": "2024-11-07T11:02:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "body": "There's nothing much we can do about this situation, and you have the exact same problem when using STUN.\r\n\r\nMaybe we should point out that different endpoints might observe different addresses?",
          "createdAt": "2024-11-07T11:02:15Z",
          "updatedAt": "2024-11-07T11:02:15Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOKhxVW85dO8Vf",
      "title": "explain how to use REQUEST_ADDRESS to detect NAT rebinding",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/2",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1.",
      "createdAt": "2023-10-19T07:25:44Z",
      "updatedAt": "2023-10-19T07:31:44Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "562e12708287e1bc503227e47f39c67fe4646d13",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "nat-rebinding",
      "headRefOid": "2dbdaf399552b0036fa6b52bc54e62d29809ee6f",
      "closedAt": "2023-10-19T07:31:44Z",
      "mergedAt": "2023-10-19T07:31:44Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "5ceddb699fb96f110a1d4b4b68fc490d10eaa040"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOKhxVW85mkVuU",
      "title": "change sequence number to request ID",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/8",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "There's no reason this needs to be sequential.\r\n\r\nFixes #5.",
      "createdAt": "2024-02-11T01:52:19Z",
      "updatedAt": "2024-02-11T01:53:51Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "5ceddb699fb96f110a1d4b4b68fc490d10eaa040",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "request-id",
      "headRefOid": "8d5c116ee69a3ea3a9d43a73d9926387586fa823",
      "closedAt": "2024-02-11T01:53:50Z",
      "mergedAt": "2024-02-11T01:53:50Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "e2ce06edb4a4949af1230ffcc9e458a83a6d1336"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOKhxVW85nJqJl",
      "title": "remove Marten's affiliation",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/9",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-17T03:07:33Z",
      "updatedAt": "2024-02-17T03:08:54Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "e2ce06edb4a4949af1230ffcc9e458a83a6d1336",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "remove-protocol-labs",
      "headRefOid": "3c1898be45870b926442134c3741a5c6fd4051cb",
      "closedAt": "2024-02-17T03:08:54Z",
      "mergedAt": "2024-02-17T03:08:54Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "fefbb97f06ab436c67889d132cd1ce8b4ebaf20c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOKhxVW85n_FBf",
      "title": "negotiate send / receive behavior, send OBSERVED_ADDRESS on new paths",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/10",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #7. Closes #4.",
      "createdAt": "2024-02-27T01:43:24Z",
      "updatedAt": "2024-02-27T01:48:09Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "fefbb97f06ab436c67889d132cd1ce8b4ebaf20c",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "no-request-response",
      "headRefOid": "09857ed5f208a9c22a3f358f23fde1e92b4f5523",
      "closedAt": "2024-02-27T01:48:09Z",
      "mergedAt": "2024-02-27T01:48:09Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "2e853642334a5422d85c5f73faf9d075b645d2b2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOKhxVW85oO9tR",
      "title": "minor editorial changes",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/11",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-29T00:36:43Z",
      "updatedAt": "2024-02-29T00:39:00Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "2e853642334a5422d85c5f73faf9d075b645d2b2",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "editorial",
      "headRefOid": "f47f9877361929e1bcb8c5e22abda59c19028c35",
      "closedAt": "2024-02-29T00:39:00Z",
      "mergedAt": "2024-02-29T00:39:00Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "aa59fafb851a9f4451fc2dca92b89a7e06e72ade"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "PR_kwDOKhxVW854zXYo",
      "title": "remove Request ID from OBSERVED_ADDRESS frame",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/14",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-20T02:59:40Z",
      "updatedAt": "2024-08-20T04:25:22Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "aa59fafb851a9f4451fc2dca92b89a7e06e72ade",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "remove-request-id",
      "headRefOid": "68aec267e60d3eacb4a9770d6e41008feb45101f",
      "closedAt": "2024-08-20T04:25:22Z",
      "mergedAt": "2024-08-20T04:25:22Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "113f4b62f97fa5fffca2249da15111c0ddce0bee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86F7ZL9",
          "commit": {
            "abbreviatedOid": "68aec26"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "That's certainly a clarification, and thus an improvement. We have a related issue of differentiating between delayed packets (loss recovery, etc.) and new values, but we can discuss that in a separate issue/PR.",
          "createdAt": "2024-08-20T04:23:47Z",
          "updatedAt": "2024-08-20T04:23:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 15,
      "id": "PR_kwDOKhxVW854zYKV",
      "title": "clarify that retransmissions happen on the same path",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/15",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #12.\r\n\r\n@huitema, wdyt?",
      "createdAt": "2024-08-20T03:03:24Z",
      "updatedAt": "2024-08-20T04:22:03Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "aa59fafb851a9f4451fc2dca92b89a7e06e72ade",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "retransmission-on-same-path",
      "headRefOid": "18dee3251d976c032f8bcaf147a35c6413b5dbbc",
      "closedAt": "2024-08-20T04:22:03Z",
      "mergedAt": "2024-08-20T04:22:03Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "3146bc44edc41d33dc2647ba0809d2718c039047"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86F7YbN",
          "commit": {
            "abbreviatedOid": "18dee32"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Yes, that's what we discussed. If we don't go back to a request/response model, that's what we need.",
          "createdAt": "2024-08-20T04:19:53Z",
          "updatedAt": "2024-08-20T04:19:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhxVW86F7Ydy",
          "commit": {
            "abbreviatedOid": "18dee32"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T04:20:05Z",
          "updatedAt": "2024-08-20T04:20:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOKhxVW854zohW",
      "title": "bump code points for transport parameter and frame types",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/16",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "draft-02 was published prematurely without changing the code points, despite a breaking change to the wire format of the OBSERVED_ADDRESS frame.",
      "createdAt": "2024-08-20T04:32:08Z",
      "updatedAt": "2024-08-20T04:36:10Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "113f4b62f97fa5fffca2249da15111c0ddce0bee",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "bump-code-points",
      "headRefOid": "8870277fbb62bb5cc00a20cf5b3907f5e3f28b25",
      "closedAt": "2024-08-20T04:36:10Z",
      "mergedAt": "2024-08-20T04:36:10Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "0f3d50e96f3f0695709ab4b6ca32a39e5f273de6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOKhxVW854ztdA",
      "title": "Add Christian in authors' list.",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/19",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-20T04:57:13Z",
      "updatedAt": "2024-08-20T05:09:09Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "0f3d50e96f3f0695709ab4b6ca32a39e5f273de6",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "add_christian",
      "headRefOid": "18dbf3e907452e62c59e7cfb1fe4d3a8dd8f2dbb",
      "closedAt": "2024-08-20T05:08:24Z",
      "mergedAt": "2024-08-20T05:08:24Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "f4b08be5077acd7e38bb5736c212b2dd45afe945"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86F7hIZ",
          "commit": {
            "abbreviatedOid": "9380f39"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T05:01:25Z",
          "updatedAt": "2024-08-20T05:01:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n    org: \"Private Octopus Inc.\"\r\n```",
              "createdAt": "2024-08-20T05:01:25Z",
              "updatedAt": "2024-08-20T05:01:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOKhxVW8543hix",
      "title": "Add sequence number to observed frame definition.",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/22",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a sequence number to the observed address frame, using the same format as previous drafts, and explain how this monotonically increasing sequence number is used to avoid acting on duplicated or delayed packets. Also strikes out the reference to handshake packets.\r\n\r\nClose #17",
      "createdAt": "2024-08-20T14:36:50Z",
      "updatedAt": "2024-08-21T06:09:29Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "f4b08be5077acd7e38bb5736c212b2dd45afe945",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "sequence_number",
      "headRefOid": "1725f38ea9f53c40e46529b1b07bc3904f662e28",
      "closedAt": "2024-08-21T05:19:41Z",
      "mergedAt": "2024-08-21T05:19:41Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "0f36a0e20c3866534dfcc0321f40f81e165512b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86GF76A",
          "commit": {
            "abbreviatedOid": "9bef167"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T04:48:48Z",
          "updatedAt": "2024-08-21T04:48:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Let's do this in a separate PR.\r\n```suggestion\r\nThis frame MUST only appear in the handshake and in the application data packet\r\n```",
              "createdAt": "2024-08-21T04:48:49Z",
              "updatedAt": "2024-08-21T04:48:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GGEEI",
          "commit": {
            "abbreviatedOid": "9bef167"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-21T05:14:44Z",
          "updatedAt": "2024-08-21T05:14:44Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "OK.",
              "createdAt": "2024-08-21T05:14:44Z",
              "updatedAt": "2024-08-21T05:14:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GGFQ3",
          "commit": {
            "abbreviatedOid": "1725f38"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-21T05:19:15Z",
          "updatedAt": "2024-08-21T05:19:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOKhxVW8545GTU",
      "title": "Describe the spoofed source address attack.",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/23",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Close #18",
      "createdAt": "2024-08-20T18:36:14Z",
      "updatedAt": "2024-08-24T02:46:02Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "f4b08be5077acd7e38bb5736c212b2dd45afe945",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "address_attack",
      "headRefOid": "c105bfccbbd1466640b031cfa59d20512794c848",
      "closedAt": "2024-08-24T02:46:02Z",
      "mergedAt": "2024-08-24T02:46:02Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "96bc34902d3ae695e38d623b72796497eea039a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86GfV6c",
          "commit": {
            "abbreviatedOid": "6add9c0"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T05:00:16Z",
          "updatedAt": "2024-08-23T05:02:44Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nOn-path attackers could capture packets sent from the requester to the\r\n```",
              "createdAt": "2024-08-23T05:00:16Z",
              "updatedAt": "2024-08-23T05:02:44Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nresponder, and resend them from a spoofed source address. If done repeatedly,\r\nthese spoofed packets could trigger the sending of a large number of OBSERVED_ADDRESS frames.\r\n```",
              "createdAt": "2024-08-23T05:01:07Z",
              "updatedAt": "2024-08-23T05:02:44Z"
            },
            {
              "originalPosition": 28,
              "body": "How does this protect against the sender?",
              "createdAt": "2024-08-23T05:02:05Z",
              "updatedAt": "2024-08-23T05:02:44Z"
            },
            {
              "originalPosition": 33,
              "body": "Should we link to the section in RFC 9000 that describes this attack?",
              "createdAt": "2024-08-23T05:02:42Z",
              "updatedAt": "2024-08-23T05:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GfZjl",
          "commit": {
            "abbreviatedOid": "6add9c0"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T05:17:36Z",
          "updatedAt": "2024-08-23T05:17:36Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "If sent over the same path, they will only reach the peer if the path is valid, thus will not have an effect on the peer. So, no pollution. But yes, still a volume effect. Maybe that could be said differently",
              "createdAt": "2024-08-23T05:17:36Z",
              "updatedAt": "2024-08-23T05:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GfZn-",
          "commit": {
            "abbreviatedOid": "6add9c0"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T05:17:55Z",
          "updatedAt": "2024-08-23T05:17:55Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yes.",
              "createdAt": "2024-08-23T05:17:55Z",
              "updatedAt": "2024-08-23T05:17:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86Gfcfx",
          "commit": {
            "abbreviatedOid": "6add9c0"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T05:29:47Z",
          "updatedAt": "2024-08-23T05:29:47Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Check the most recent commit please.",
              "createdAt": "2024-08-23T05:29:47Z",
              "updatedAt": "2024-08-23T05:29:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GffIq",
          "commit": {
            "abbreviatedOid": "7a36e85"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "The new text sounds a lot better. I added a few further suggestions.",
          "createdAt": "2024-08-23T05:40:59Z",
          "updatedAt": "2024-08-23T05:43:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nthat the peer will not receive the OBSERVED_ADDRESS frames if the\r\n```",
              "createdAt": "2024-08-23T05:40:59Z",
              "updatedAt": "2024-08-23T05:43:12Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\naddresses are not valid, but this does not reduce the number of\r\n```",
              "createdAt": "2024-08-23T05:41:17Z",
              "updatedAt": "2024-08-23T05:43:12Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nQUIC implementations are expected to have sufficient\r\n```",
              "createdAt": "2024-08-23T05:42:07Z",
              "updatedAt": "2024-08-23T05:43:12Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\ncaused by such attacks. The same protection logic SHOULD be used to prevent sending of a large number of\r\nspurious OBSERVED_ADDRESS frames.\r\n```",
              "createdAt": "2024-08-23T05:42:55Z",
              "updatedAt": "2024-08-23T05:43:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86GmuUA",
          "commit": {
            "abbreviatedOid": "c105bfc"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-24T02:45:48Z",
          "updatedAt": "2024-08-24T02:45:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOKhxVW855Ea5K",
      "title": "disallow OBSERVED_ADDRESS frame in Handshake packets",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/25",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #21.",
      "createdAt": "2024-08-22T03:32:56Z",
      "updatedAt": "2024-08-25T13:11:33Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "0f36a0e20c3866534dfcc0321f40f81e165512b8",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "no-more-handshake-packets",
      "headRefOid": "261362b80f67a44d952d19af89d16dec473f9aca",
      "closedAt": "2024-08-22T06:32:50Z",
      "mergedAt": "2024-08-22T06:32:50Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "ad0a0e73279c94b9cd2dda5d5f8e050429e38a0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86GUu-_",
          "commit": {
            "abbreviatedOid": "261362b"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-22T06:13:49Z",
          "updatedAt": "2024-08-22T06:13:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhxVW86GqWqg",
          "commit": {
            "abbreviatedOid": "261362b"
          },
          "author": "flub",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-25T13:11:33Z",
          "updatedAt": "2024-08-25T13:11:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "why not add a note about the 0.5RTT and coalesced packet?  Would that not be helpful guidance for implementers?",
              "createdAt": "2024-08-25T13:11:33Z",
              "updatedAt": "2024-08-25T13:11:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 26,
      "id": "PR_kwDOKhxVW855MlW3",
      "title": "Update the TP and frame numbers for draft 04",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/26",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am proposing to do the same kind of change as between draft-02 and draft-03.\r\nWe will cut a new version when we get the shorter numbers from IANA.",
      "createdAt": "2024-08-23T03:32:18Z",
      "updatedAt": "2024-08-23T04:30:56Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "ad0a0e73279c94b9cd2dda5d5f8e050429e38a0e",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "draft4-numbers",
      "headRefOid": "b5d259fd4d27361a1375dc74c6b1ec8f3ae9f82b",
      "closedAt": "2024-08-23T04:30:56Z",
      "mergedAt": "2024-08-23T04:30:56Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "8231bc0f2b2b33652fb728830fef965802173ebd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86GfNYK",
          "commit": {
            "abbreviatedOid": "b5d259f"
          },
          "author": "marten-seemann",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-23T04:30:19Z",
          "updatedAt": "2024-08-23T04:30:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOKhxVW85-Y8W4",
      "title": "make QUIC bit greasing (RFC 9287) a non-normative reference",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/28",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-12T01:18:19Z",
      "updatedAt": "2024-10-12T01:54:30Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "96bc34902d3ae695e38d623b72796497eea039a8",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "quic-bit-greasing-non-normative",
      "headRefOid": "20798fddf14427512c3f0ea57ddb70b3d62c50ed",
      "closedAt": "2024-10-12T01:54:30Z",
      "mergedAt": "2024-10-12T01:54:30Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "9cea7709c09d06c75aa83a48624cbca1f50f2b6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86M42kM",
          "commit": {
            "abbreviatedOid": "20798fd"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-12T01:52:42Z",
          "updatedAt": "2024-10-12T01:52:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOKhxVW85-Y86g",
      "title": "OBSERVED_ADDRESS cannot be sent during the handshake",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/29",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This should probably have been part of #25.",
      "createdAt": "2024-10-12T01:23:18Z",
      "updatedAt": "2024-10-12T01:59:56Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "96bc34902d3ae695e38d623b72796497eea039a8",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "no-observed-address-during-handshake",
      "headRefOid": "3c1b8b7d557f147fcbd558df2049f84179c884c3",
      "closedAt": "2024-10-12T01:59:56Z",
      "mergedAt": "2024-10-12T01:59:56Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "2910a12d8f0a2de7cca2ac9c25e0c6a63f908a58"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86M42pl",
          "commit": {
            "abbreviatedOid": "3c1b8b7"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-12T01:54:45Z",
          "updatedAt": "2024-10-12T01:54:53Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yes. We only send these frames in 1RTT packets, so there is little need to specify timing.",
              "createdAt": "2024-10-12T01:54:45Z",
              "updatedAt": "2024-10-12T01:54:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKhxVW86M42un",
          "commit": {
            "abbreviatedOid": "3c1b8b7"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-12T01:55:32Z",
          "updatedAt": "2024-10-12T01:55:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOKhxVW86BK8bL",
      "title": "acknowledge draft-pauly-quic-address-extension",
      "url": "https://github.com/marten-seemann/draft-seemann-quic-address-discovery/pull/36",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-11-07T11:01:07Z",
      "updatedAt": "2024-11-08T08:31:36Z",
      "baseRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "baseRefName": "main",
      "baseRefOid": "2910a12d8f0a2de7cca2ac9c25e0c6a63f908a58",
      "headRepository": "marten-seemann/draft-seemann-quic-address-discovery",
      "headRefName": "pauly-quic-address-extension",
      "headRefOid": "d0767a31121f02126bb4516f6250b8da98bde44e",
      "closedAt": "2024-11-08T08:31:36Z",
      "mergedAt": "2024-11-08T08:31:36Z",
      "mergedBy": "marten-seemann",
      "mergeCommit": {
        "oid": "2c8ff0314d8e1fb2240d810a6d85648ab3e680c7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKhxVW86QUu8W",
          "commit": {
            "abbreviatedOid": "d0767a3"
          },
          "author": "huitema",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-07T15:38:18Z",
          "updatedAt": "2024-11-07T15:38:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKhxVW86QUwzJ",
          "commit": {
            "abbreviatedOid": "d0767a3"
          },
          "author": "nibanks",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-11-07T15:41:04Z",
          "updatedAt": "2024-11-07T15:41:04Z",
          "comments": []
        }
      ]
    }
  ]
}